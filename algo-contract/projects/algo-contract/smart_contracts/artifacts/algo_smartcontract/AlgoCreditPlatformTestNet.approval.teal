#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 1000000 50 1000000000 100000
    bytecblock 0x151f7c75 "totalFundsInvested" "totalFundsDeposited" "platformFees" "contractActive" "totalActiveLoans" "totalInvestors" "totalStartups" "totalApiKeys" "totalTokenizedStartups" "totalLoanRequests" "totalInvestments" 0x151f7c750000000000000001 "Platform is currently inactive" "Investment amount must be greater than 0" "Funding amount must be greater than 0" "Invalid loan ID" "Insufficient available funds"
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txn NumAppArgs
    bz main_bare_routing@37
    pushbytess 0x02bece11 0xf43287ab 0x881eb5af 0x9e641817 0x94f0ea89 0x7eac1ca1 0x1f523c74 0xff8437eb 0xf59c7cec 0x7fa0dca0 0xa14ba69d 0x64e2bb78 0xa57c633e 0x9ad40acb 0x9824c702 0x1b294dcc 0x790f3af8 0x45e19fa9 0xcb45a8b7 0x587aa573 0xe476d182 0xee57c82c 0x11237b48 0xbe5e72a0 0xd7a79c2f 0xc5dcad3f 0x8a1dac4b 0x5c8ee5d2 0xee7a7d04 0xf65cc277 0x09c3d5fd 0x8052215e // method "hello(string)string", method "registerInvestor(string,uint64)string", method "registerApiKey(string,string,string)string", method "getApiKeyCount()uint64", method "canGenerateApiKey(string)uint64", method "registerStartup(string,string,uint64)string", method "tokenizeStartup(string,uint64,uint64,string)string", method "requestLoan(uint64,uint64,uint64)string", method "getInvestorCount()uint64", method "getStartupCount()uint64", method "getTokenizedStartupsCount()uint64", method "getTotalInvestmentsCount()uint64", method "getLoanRequestCount()uint64", method "investInStartup(uint64,uint64,uint64)string", method "realDeposit()string", method "simulateDeposit(uint64)string", method "realWithdraw(uint64)string", method "simulateInvestment(uint64)string", method "getAvailableFunds()uint64", method "getTotalDeposited()uint64", method "getTotalInvested()uint64", method "getPlatformFees()uint64", method "getPlatformStats()string", method "getContractInfo()string", method "realLoanFunding(uint64,uint64)string", method "simulateLoanFunding(uint64,uint64)string", method "isContractActive()uint64", method "getActiveLoansCount()uint64", method "togglePlatformStatus()string", method "collectPlatformFees()string", method "getPlatformFeesAmount()uint64", method "testPlatform()string"
    txna ApplicationArgs 0
    match main_hello_route@3 main_registerInvestor_route@4 main_registerApiKey_route@5 main_getApiKeyCount_route@6 main_canGenerateApiKey_route@7 main_registerStartup_route@8 main_tokenizeStartup_route@9 main_requestLoan_route@10 main_getInvestorCount_route@11 main_getStartupCount_route@12 main_getTokenizedStartupsCount_route@13 main_getTotalInvestmentsCount_route@14 main_getLoanRequestCount_route@15 main_investInStartup_route@16 main_realDeposit_route@17 main_simulateDeposit_route@18 main_realWithdraw_route@19 main_simulateInvestment_route@20 main_getAvailableFunds_route@21 main_getTotalDeposited_route@22 main_getTotalInvested_route@23 main_getPlatformFees_route@24 main_getPlatformStats_route@25 main_getContractInfo_route@26 main_realLoanFunding_route@27 main_simulateLoanFunding_route@28 main_isContractActive_route@29 main_getActiveLoansCount_route@30 main_togglePlatformStatus_route@31 main_collectPlatformFees_route@32 main_getPlatformFeesAmount_route@33 main_testPlatform_route@34

main_after_if_else@41:
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    intc_0 // 0
    return

main_testPlatform_route@34:
    // smart_contracts/algo_smartcontract/contract.algo.ts:464
    // testPlatform(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub testPlatform
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPlatformFeesAmount_route@33:
    // smart_contracts/algo_smartcontract/contract.algo.ts:457
    // getPlatformFeesAmount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPlatformFeesAmount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_collectPlatformFees_route@32:
    // smart_contracts/algo_smartcontract/contract.algo.ts:438
    // collectPlatformFees(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub collectPlatformFees
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_togglePlatformStatus_route@31:
    // smart_contracts/algo_smartcontract/contract.algo.ts:425
    // togglePlatformStatus(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub togglePlatformStatus
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getActiveLoansCount_route@30:
    // smart_contracts/algo_smartcontract/contract.algo.ts:418
    // getActiveLoansCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getActiveLoansCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isContractActive_route@29:
    // smart_contracts/algo_smartcontract/contract.algo.ts:409
    // isContractActive(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 12 // 0x151f7c750000000000000001
    log
    intc_1 // 1
    return

main_simulateLoanFunding_route@28:
    // smart_contracts/algo_smartcontract/contract.algo.ts:381
    // simulateLoanFunding(loanId: uint64, amount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:381
    // simulateLoanFunding(loanId: uint64, amount: uint64): string {
    callsub simulateLoanFunding
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_realLoanFunding_route@27:
    // smart_contracts/algo_smartcontract/contract.algo.ts:350
    // realLoanFunding(loanId: uint64, amount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:350
    // realLoanFunding(loanId: uint64, amount: uint64): string {
    callsub realLoanFunding
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getContractInfo_route@26:
    // smart_contracts/algo_smartcontract/contract.algo.ts:343
    // getContractInfo(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75002e416c676f43726564697420506c6174666f726d2076332e30202d205265616c205061796d656e7473205265616479
    log
    intc_1 // 1
    return

main_getPlatformStats_route@25:
    // smart_contracts/algo_smartcontract/contract.algo.ts:329
    // getPlatformStats(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPlatformStats
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPlatformFees_route@24:
    // smart_contracts/algo_smartcontract/contract.algo.ts:322
    // getPlatformFees(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPlatformFees
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTotalInvested_route@23:
    // smart_contracts/algo_smartcontract/contract.algo.ts:315
    // getTotalInvested(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalInvested
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTotalDeposited_route@22:
    // smart_contracts/algo_smartcontract/contract.algo.ts:308
    // getTotalDeposited(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalDeposited
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getAvailableFunds_route@21:
    // smart_contracts/algo_smartcontract/contract.algo.ts:301
    // getAvailableFunds(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getAvailableFunds
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_simulateInvestment_route@20:
    // smart_contracts/algo_smartcontract/contract.algo.ts:281
    // simulateInvestment(amount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:281
    // simulateInvestment(amount: uint64): string {
    callsub simulateInvestment
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_realWithdraw_route@19:
    // smart_contracts/algo_smartcontract/contract.algo.ts:253
    // realWithdraw(amount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:253
    // realWithdraw(amount: uint64): string {
    callsub realWithdraw
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_simulateDeposit_route@18:
    // smart_contracts/algo_smartcontract/contract.algo.ts:233
    // simulateDeposit(amount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:233
    // simulateDeposit(amount: uint64): string {
    callsub simulateDeposit
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_realDeposit_route@17:
    // smart_contracts/algo_smartcontract/contract.algo.ts:217
    // realDeposit(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub realDeposit
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_investInStartup_route@16:
    // smart_contracts/algo_smartcontract/contract.algo.ts:184
    // investInStartup(startupId: uint64, investmentAmount: uint64, tokenAmount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:184
    // investInStartup(startupId: uint64, investmentAmount: uint64, tokenAmount: uint64): string {
    callsub investInStartup
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getLoanRequestCount_route@15:
    // smart_contracts/algo_smartcontract/contract.algo.ts:176
    // getLoanRequestCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getLoanRequestCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTotalInvestmentsCount_route@14:
    // smart_contracts/algo_smartcontract/contract.algo.ts:168
    // getTotalInvestmentsCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalInvestmentsCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTokenizedStartupsCount_route@13:
    // smart_contracts/algo_smartcontract/contract.algo.ts:160
    // getTokenizedStartupsCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTokenizedStartupsCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getStartupCount_route@12:
    // smart_contracts/algo_smartcontract/contract.algo.ts:152
    // getStartupCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getStartupCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getInvestorCount_route@11:
    // smart_contracts/algo_smartcontract/contract.algo.ts:144
    // getInvestorCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getInvestorCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_requestLoan_route@10:
    // smart_contracts/algo_smartcontract/contract.algo.ts:110
    // requestLoan(amount: uint64, duration: uint64, interestRate: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:110
    // requestLoan(amount: uint64, duration: uint64, interestRate: uint64): string {
    callsub requestLoan
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_tokenizeStartup_route@9:
    // smart_contracts/algo_smartcontract/contract.algo.ts:91
    // tokenizeStartup(startupName: string, tokenPrice: uint64, totalSupply: uint64, industry: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/algo_smartcontract/contract.algo.ts:91
    // tokenizeStartup(startupName: string, tokenPrice: uint64, totalSupply: uint64, industry: string): string {
    callsub tokenizeStartup
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registerStartup_route@8:
    // smart_contracts/algo_smartcontract/contract.algo.ts:71
    // registerStartup(startupName: string, industry: string, requestedAmount: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:71
    // registerStartup(startupName: string, industry: string, requestedAmount: uint64): string {
    callsub registerStartup
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_canGenerateApiKey_route@7:
    // smart_contracts/algo_smartcontract/contract.algo.ts:64
    // canGenerateApiKey(walletAddress: string): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 12 // 0x151f7c750000000000000001
    log
    intc_1 // 1
    return

main_getApiKeyCount_route@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:57
    // getApiKeyCount(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getApiKeyCount
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registerApiKey_route@5:
    // smart_contracts/algo_smartcontract/contract.algo.ts:46
    // registerApiKey(walletAddress: string, apiKeyHash: string, tier: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/algo_smartcontract/contract.algo.ts:46
    // registerApiKey(walletAddress: string, apiKeyHash: string, tier: string): string {
    callsub registerApiKey
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registerInvestor_route@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:31
    // registerInvestor(investorType: string, riskLevel: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/algo_smartcontract/contract.algo.ts:31
    // registerInvestor(investorType: string, riskLevel: uint64): string {
    callsub registerInvestor
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_hello_route@3:
    // smart_contracts/algo_smartcontract/contract.algo.ts:23
    // hello(name: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/algo_smartcontract/contract.algo.ts:23
    // hello(name: string): string {
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@37:
    // smart_contracts/algo_smartcontract/contract.algo.ts:3
    // export class AlgoCreditPlatformTestNet extends Contract {
    txn OnCompletion
    bnz main_after_if_else@41
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/algo_smartcontract/contract.algo.ts:23
    // hello(name: string): string {
    proto 1 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:24
    // return `Hello, ${name}`
    pushbytes "Hello, "
    frame_dig -1
    concat
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.registerInvestor(investorType: bytes, riskLevel: uint64) -> bytes:
registerInvestor:
    // smart_contracts/algo_smartcontract/contract.algo.ts:31
    // registerInvestor(investorType: string, riskLevel: uint64): string {
    proto 2 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:33
    // if (riskLevel < 1 || riskLevel > 10) {
    frame_dig -1
    intc_1 // 1
    <
    bnz registerInvestor_if_body@2
    frame_dig -1
    pushint 10 // 10
    >
    bz registerInvestor_after_if_else@3

registerInvestor_if_body@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:34
    // return 'Risk level must be between 1 and 10'
    pushbytes "Risk level must be between 1 and 10"
    retsub

registerInvestor_after_if_else@3:
    // smart_contracts/algo_smartcontract/contract.algo.ts:5
    // totalInvestors = GlobalState<uint64>()
    intc_0 // 0
    bytec 6 // "totalInvestors"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:38
    // this.totalInvestors.value = this.totalInvestors.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:5
    // totalInvestors = GlobalState<uint64>()
    bytec 6 // "totalInvestors"
    // smart_contracts/algo_smartcontract/contract.algo.ts:38
    // this.totalInvestors.value = this.totalInvestors.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:40
    // return 'Investor registered successfully'
    pushbytes "Investor registered successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.registerApiKey(walletAddress: bytes, apiKeyHash: bytes, tier: bytes) -> bytes:
registerApiKey:
    // smart_contracts/algo_smartcontract/contract.algo.ts:46
    // registerApiKey(walletAddress: string, apiKeyHash: string, tier: string): string {
    proto 3 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:15
    // totalApiKeys = GlobalState<uint64>() // Total API keys generated
    intc_0 // 0
    bytec 8 // "totalApiKeys"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:48
    // this.totalApiKeys.value = this.totalApiKeys.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:15
    // totalApiKeys = GlobalState<uint64>() // Total API keys generated
    bytec 8 // "totalApiKeys"
    // smart_contracts/algo_smartcontract/contract.algo.ts:48
    // this.totalApiKeys.value = this.totalApiKeys.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:51
    // return 'API key registered for wallet: ' + walletAddress + ' tier: ' + tier
    pushbytes "API key registered for wallet: "
    frame_dig -3
    concat
    pushbytes " tier: "
    concat
    frame_dig -1
    concat
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getApiKeyCount() -> uint64:
getApiKeyCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:15
    // totalApiKeys = GlobalState<uint64>() // Total API keys generated
    intc_0 // 0
    bytec 8 // "totalApiKeys"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:58
    // return this.totalApiKeys.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.registerStartup(startupName: bytes, industry: bytes, requestedAmount: uint64) -> bytes:
registerStartup:
    // smart_contracts/algo_smartcontract/contract.algo.ts:71
    // registerStartup(startupName: string, industry: string, requestedAmount: uint64): string {
    proto 3 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:73
    // if (requestedAmount < 1000000) {
    frame_dig -1
    intc_2 // 1000000
    <
    bz registerStartup_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:74
    // return 'Minimum loan request is 1 ALGO'
    pushbytes "Minimum loan request is 1 ALGO"
    retsub

registerStartup_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:78
    // if (requestedAmount > 1000000000) {
    frame_dig -1
    intc 4 // 1000000000
    >
    bz registerStartup_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:79
    // return 'Maximum loan request is 1000 ALGO'
    pushbytes "Maximum loan request is 1000 ALGO"
    retsub

registerStartup_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:6
    // totalStartups = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "totalStartups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:83
    // this.totalStartups.value = this.totalStartups.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:6
    // totalStartups = GlobalState<uint64>()
    bytec 7 // "totalStartups"
    // smart_contracts/algo_smartcontract/contract.algo.ts:83
    // this.totalStartups.value = this.totalStartups.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:85
    // return 'Startup registered successfully: ' + startupName + ' in ' + industry
    pushbytes "Startup registered successfully: "
    frame_dig -3
    concat
    pushbytes " in "
    concat
    frame_dig -2
    concat
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.tokenizeStartup(startupName: bytes, tokenPrice: uint64, totalSupply: uint64, industry: bytes) -> bytes:
tokenizeStartup:
    // smart_contracts/algo_smartcontract/contract.algo.ts:91
    // tokenizeStartup(startupName: string, tokenPrice: uint64, totalSupply: uint64, industry: string): string {
    proto 4 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:93
    // if (tokenPrice <= 0) {
    frame_dig -3
    intc_0 // 0
    <=
    bz tokenizeStartup_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:94
    // return 'Token price must be greater than 0'
    pushbytes "Token price must be greater than 0"
    retsub

tokenizeStartup_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:97
    // if (totalSupply <= 0) {
    frame_dig -2
    intc_0 // 0
    <=
    bz tokenizeStartup_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:98
    // return 'Total supply must be greater than 0'
    pushbytes "Total supply must be greater than 0"
    retsub

tokenizeStartup_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:7
    // totalTokenizedStartups = GlobalState<uint64>()
    intc_0 // 0
    bytec 9 // "totalTokenizedStartups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:102
    // this.totalTokenizedStartups.value = this.totalTokenizedStartups.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:7
    // totalTokenizedStartups = GlobalState<uint64>()
    bytec 9 // "totalTokenizedStartups"
    // smart_contracts/algo_smartcontract/contract.algo.ts:102
    // this.totalTokenizedStartups.value = this.totalTokenizedStartups.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:104
    // return 'Startup tokenized successfully: ' + startupName
    pushbytes "Startup tokenized successfully: "
    frame_dig -4
    concat
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.requestLoan(amount: uint64, duration: uint64, interestRate: uint64) -> bytes:
requestLoan:
    // smart_contracts/algo_smartcontract/contract.algo.ts:110
    // requestLoan(amount: uint64, duration: uint64, interestRate: uint64): string {
    proto 3 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    intc_0 // 0
    bytec 4 // "contractActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:112
    // if (this.contractActive.value === 0) {
    bnz requestLoan_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:113
    // return 'Platform is currently inactive'
    bytec 13 // "Platform is currently inactive"
    retsub

requestLoan_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:117
    // if (amount < 1000000) {
    frame_dig -3
    intc_2 // 1000000
    <
    bz requestLoan_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:118
    // return 'Minimum loan amount is 1 ALGO'
    pushbytes "Minimum loan amount is 1 ALGO"
    retsub

requestLoan_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:121
    // if (amount > 1000000000) {
    frame_dig -3
    intc 4 // 1000000000
    >
    bz requestLoan_after_if_else@6
    // smart_contracts/algo_smartcontract/contract.algo.ts:122
    // return 'Maximum loan amount is 1000 ALGO'
    pushbytes "Maximum loan amount is 1000 ALGO"
    retsub

requestLoan_after_if_else@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:126
    // if (duration < 1 || duration > 60) {
    frame_dig -2
    intc_1 // 1
    <
    bnz requestLoan_if_body@8
    frame_dig -2
    pushint 60 // 60
    >
    bz requestLoan_after_if_else@9

requestLoan_if_body@8:
    // smart_contracts/algo_smartcontract/contract.algo.ts:127
    // return 'Loan duration must be between 1-60 months'
    pushbytes "Loan duration must be between 1-60 months"
    retsub

requestLoan_after_if_else@9:
    // smart_contracts/algo_smartcontract/contract.algo.ts:131
    // if (interestRate < 1 || interestRate > 30) {
    frame_dig -1
    intc_1 // 1
    <
    bnz requestLoan_if_body@11
    frame_dig -1
    pushint 30 // 30
    >
    bz requestLoan_after_if_else@12

requestLoan_if_body@11:
    // smart_contracts/algo_smartcontract/contract.algo.ts:132
    // return 'Interest rate must be between 1-30%'
    pushbytes "Interest rate must be between 1-30%"
    retsub

requestLoan_after_if_else@12:
    // smart_contracts/algo_smartcontract/contract.algo.ts:10
    // totalLoanRequests = GlobalState<uint64>()
    intc_0 // 0
    bytec 10 // "totalLoanRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:136
    // this.totalLoanRequests.value = this.totalLoanRequests.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:10
    // totalLoanRequests = GlobalState<uint64>()
    bytec 10 // "totalLoanRequests"
    // smart_contracts/algo_smartcontract/contract.algo.ts:136
    // this.totalLoanRequests.value = this.totalLoanRequests.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:138
    // return 'Loan request created successfully'
    pushbytes "Loan request created successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getInvestorCount() -> uint64:
getInvestorCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:5
    // totalInvestors = GlobalState<uint64>()
    intc_0 // 0
    bytec 6 // "totalInvestors"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:146
    // return this.totalInvestors.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getStartupCount() -> uint64:
getStartupCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:6
    // totalStartups = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "totalStartups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:154
    // return this.totalStartups.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getTokenizedStartupsCount() -> uint64:
getTokenizedStartupsCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:7
    // totalTokenizedStartups = GlobalState<uint64>()
    intc_0 // 0
    bytec 9 // "totalTokenizedStartups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:162
    // return this.totalTokenizedStartups.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getTotalInvestmentsCount() -> uint64:
getTotalInvestmentsCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:12
    // totalInvestments = GlobalState<uint64>()
    intc_0 // 0
    bytec 11 // "totalInvestments"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:170
    // return this.totalInvestments.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getLoanRequestCount() -> uint64:
getLoanRequestCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:10
    // totalLoanRequests = GlobalState<uint64>()
    intc_0 // 0
    bytec 10 // "totalLoanRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:178
    // return this.totalLoanRequests.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.investInStartup(startupId: uint64, investmentAmount: uint64, tokenAmount: uint64) -> bytes:
investInStartup:
    // smart_contracts/algo_smartcontract/contract.algo.ts:184
    // investInStartup(startupId: uint64, investmentAmount: uint64, tokenAmount: uint64): string {
    proto 3 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:186
    // if (investmentAmount <= 0) {
    frame_dig -2
    intc_0 // 0
    <=
    bz investInStartup_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:187
    // return 'Investment amount must be greater than 0'
    bytec 14 // "Investment amount must be greater than 0"
    retsub

investInStartup_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:190
    // if (tokenAmount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz investInStartup_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:191
    // return 'Token amount must be greater than 0'
    pushbytes "Token amount must be greater than 0"
    retsub

investInStartup_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:194
    // if (startupId <= 0) {
    frame_dig -3
    intc_0 // 0
    <=
    bz investInStartup_after_if_else@6
    // smart_contracts/algo_smartcontract/contract.algo.ts:195
    // return 'Invalid startup ID'
    pushbytes "Invalid startup ID"
    retsub

investInStartup_after_if_else@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    intc_0 // 0
    bytec 4 // "contractActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:199
    // if (this.contractActive.value === 0) {
    bnz investInStartup_after_if_else@8
    // smart_contracts/algo_smartcontract/contract.algo.ts:200
    // return 'Platform is currently inactive'
    bytec 13 // "Platform is currently inactive"
    retsub

investInStartup_after_if_else@8:
    // smart_contracts/algo_smartcontract/contract.algo.ts:12
    // totalInvestments = GlobalState<uint64>()
    intc_0 // 0
    bytec 11 // "totalInvestments"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:204
    // this.totalInvestments.value = this.totalInvestments.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:12
    // totalInvestments = GlobalState<uint64>()
    bytec 11 // "totalInvestments"
    // smart_contracts/algo_smartcontract/contract.algo.ts:204
    // this.totalInvestments.value = this.totalInvestments.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:205
    // this.totalFundsInvested.value = this.totalFundsInvested.value + investmentAmount
    frame_dig -2
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    bytec_1 // "totalFundsInvested"
    // smart_contracts/algo_smartcontract/contract.algo.ts:205
    // this.totalFundsInvested.value = this.totalFundsInvested.value + investmentAmount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:208
    // this.platformFees.value = this.platformFees.value + (investmentAmount / 50)
    frame_dig -2
    intc_3 // 50
    /
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    bytec_3 // "platformFees"
    // smart_contracts/algo_smartcontract/contract.algo.ts:208
    // this.platformFees.value = this.platformFees.value + (investmentAmount / 50)
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:210
    // return 'Investment successful in startup'
    pushbytes "Investment successful in startup"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.realDeposit() -> bytes:
realDeposit:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:225
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value + 1000000
    intc_2 // 1000000
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    bytec_2 // "totalFundsDeposited"
    // smart_contracts/algo_smartcontract/contract.algo.ts:225
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value + 1000000
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:227
    // return 'Real deposit processed: 1 ALGO'
    pushbytes "Real deposit processed: 1 ALGO"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.simulateDeposit(amount: uint64) -> bytes:
simulateDeposit:
    // smart_contracts/algo_smartcontract/contract.algo.ts:233
    // simulateDeposit(amount: uint64): string {
    proto 1 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:235
    // if (amount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz simulateDeposit_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:236
    // return 'Amount must be greater than 0'
    pushbytes "Amount must be greater than 0"
    retsub

simulateDeposit_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:240
    // if (amount < 100000) {
    frame_dig -1
    intc 5 // 100000
    <
    bz simulateDeposit_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:241
    // return 'Minimum deposit is 0.1 ALGO'
    pushbytes "Minimum deposit is 0.1 ALGO"
    retsub

simulateDeposit_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:245
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value + amount
    frame_dig -1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    bytec_2 // "totalFundsDeposited"
    // smart_contracts/algo_smartcontract/contract.algo.ts:245
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value + amount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:247
    // return 'Deposit simulated successfully'
    pushbytes "Deposit simulated successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.realWithdraw(amount: uint64) -> bytes:
realWithdraw:
    // smart_contracts/algo_smartcontract/contract.algo.ts:253
    // realWithdraw(amount: uint64): string {
    proto 1 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:255
    // if (amount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz realWithdraw_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:256
    // return 'Withdrawal amount must be greater than 0'
    pushbytes "Withdrawal amount must be greater than 0"
    retsub

realWithdraw_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:260
    // if (amount > this.totalFundsDeposited.value - this.totalFundsInvested.value) {
    -
    frame_dig -1
    <
    bz realWithdraw_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:261
    // return 'Insufficient contract funds for withdrawal'
    pushbytes "Insufficient contract funds for withdrawal"
    retsub

realWithdraw_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:265
    // if (amount < 100000) {
    frame_dig -1
    intc 5 // 100000
    <
    bz realWithdraw_after_if_else@6
    // smart_contracts/algo_smartcontract/contract.algo.ts:266
    // return 'Minimum withdrawal is 0.1 ALGO'
    pushbytes "Minimum withdrawal is 0.1 ALGO"
    retsub

realWithdraw_after_if_else@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:270
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value - amount
    frame_dig -1
    -
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    bytec_2 // "totalFundsDeposited"
    // smart_contracts/algo_smartcontract/contract.algo.ts:270
    // this.totalFundsDeposited.value = this.totalFundsDeposited.value - amount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:275
    // return 'Real withdrawal processed successfully'
    pushbytes "Real withdrawal processed successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.simulateInvestment(amount: uint64) -> bytes:
simulateInvestment:
    // smart_contracts/algo_smartcontract/contract.algo.ts:281
    // simulateInvestment(amount: uint64): string {
    proto 1 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:283
    // if (amount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz simulateInvestment_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:284
    // return 'Investment amount must be greater than 0'
    bytec 14 // "Investment amount must be greater than 0"
    retsub

simulateInvestment_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:288
    // if (amount > this.totalFundsDeposited.value - this.totalFundsInvested.value) {
    -
    frame_dig -1
    <
    bz simulateInvestment_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:289
    // return 'Insufficient available funds for investment'
    pushbytes "Insufficient available funds for investment"
    retsub

simulateInvestment_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:293
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    frame_dig -1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    bytec_1 // "totalFundsInvested"
    // smart_contracts/algo_smartcontract/contract.algo.ts:293
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:295
    // return 'Investment allocated successfully'
    pushbytes "Investment allocated successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getAvailableFunds() -> uint64:
getAvailableFunds:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:302
    // return this.totalFundsDeposited.value - this.totalFundsInvested.value
    -
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getTotalDeposited() -> uint64:
getTotalDeposited:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:309
    // return this.totalFundsDeposited.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getTotalInvested() -> uint64:
getTotalInvested:
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:316
    // return this.totalFundsInvested.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getPlatformFees() -> uint64:
getPlatformFees:
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:323
    // return this.platformFees.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getPlatformStats() -> bytes:
getPlatformStats:
    // smart_contracts/algo_smartcontract/contract.algo.ts:329
    // getPlatformStats(): string {
    proto 0 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:5
    // totalInvestors = GlobalState<uint64>()
    intc_0 // 0
    bytec 6 // "totalInvestors"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:6
    // totalStartups = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "totalStartups"
    app_global_get_ex
    swap
    cover 2
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:333
    // if (investors === 0 && startups === 0) {
    bnz getPlatformStats_after_if_else@3
    frame_dig 0
    bnz getPlatformStats_after_if_else@3
    // smart_contracts/algo_smartcontract/contract.algo.ts:334
    // return 'AlgoCredit Platform: Ready for users'
    pushbytes "AlgoCredit Platform: Ready for users"
    swap
    retsub

getPlatformStats_after_if_else@3:
    // smart_contracts/algo_smartcontract/contract.algo.ts:337
    // return 'AlgoCredit Platform: Active'
    pushbytes "AlgoCredit Platform: Active"
    swap
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.realLoanFunding(loanId: uint64, amount: uint64) -> bytes:
realLoanFunding:
    // smart_contracts/algo_smartcontract/contract.algo.ts:350
    // realLoanFunding(loanId: uint64, amount: uint64): string {
    proto 2 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:352
    // if (amount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz realLoanFunding_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:353
    // return 'Funding amount must be greater than 0'
    bytec 15 // "Funding amount must be greater than 0"
    retsub

realLoanFunding_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:356
    // if (loanId <= 0) {
    frame_dig -2
    intc_0 // 0
    <=
    bz realLoanFunding_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:357
    // return 'Invalid loan ID'
    bytec 16 // "Invalid loan ID"
    retsub

realLoanFunding_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:361
    // if (amount > this.totalFundsDeposited.value - this.totalFundsInvested.value) {
    -
    frame_dig -1
    <
    bz realLoanFunding_after_if_else@6
    // smart_contracts/algo_smartcontract/contract.algo.ts:362
    // return 'Insufficient available funds'
    bytec 17 // "Insufficient available funds"
    retsub

realLoanFunding_after_if_else@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:366
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    frame_dig -1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    bytec_1 // "totalFundsInvested"
    // smart_contracts/algo_smartcontract/contract.algo.ts:366
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:11
    // totalActiveLoans = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalActiveLoans"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:367
    // this.totalActiveLoans.value = this.totalActiveLoans.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:11
    // totalActiveLoans = GlobalState<uint64>()
    bytec 5 // "totalActiveLoans"
    // smart_contracts/algo_smartcontract/contract.algo.ts:367
    // this.totalActiveLoans.value = this.totalActiveLoans.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:370
    // this.platformFees.value = this.platformFees.value + (amount / 50)
    frame_dig -1
    intc_3 // 50
    /
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    bytec_3 // "platformFees"
    // smart_contracts/algo_smartcontract/contract.algo.ts:370
    // this.platformFees.value = this.platformFees.value + (amount / 50)
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:375
    // return 'Real loan funding processed successfully'
    pushbytes "Real loan funding processed successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.simulateLoanFunding(loanId: uint64, amount: uint64) -> bytes:
simulateLoanFunding:
    // smart_contracts/algo_smartcontract/contract.algo.ts:381
    // simulateLoanFunding(loanId: uint64, amount: uint64): string {
    proto 2 1
    // smart_contracts/algo_smartcontract/contract.algo.ts:383
    // if (amount <= 0) {
    frame_dig -1
    intc_0 // 0
    <=
    bz simulateLoanFunding_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:384
    // return 'Funding amount must be greater than 0'
    bytec 15 // "Funding amount must be greater than 0"
    retsub

simulateLoanFunding_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:387
    // if (loanId <= 0) {
    frame_dig -2
    intc_0 // 0
    <=
    bz simulateLoanFunding_after_if_else@4
    // smart_contracts/algo_smartcontract/contract.algo.ts:388
    // return 'Invalid loan ID'
    bytec 16 // "Invalid loan ID"
    retsub

simulateLoanFunding_after_if_else@4:
    // smart_contracts/algo_smartcontract/contract.algo.ts:8
    // totalFundsDeposited = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalFundsDeposited"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:392
    // if (amount > this.totalFundsDeposited.value - this.totalFundsInvested.value) {
    -
    frame_dig -1
    <
    bz simulateLoanFunding_after_if_else@6
    // smart_contracts/algo_smartcontract/contract.algo.ts:393
    // return 'Insufficient available funds'
    bytec 17 // "Insufficient available funds"
    retsub

simulateLoanFunding_after_if_else@6:
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "totalFundsInvested"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:397
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    frame_dig -1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:9
    // totalFundsInvested = GlobalState<uint64>()
    bytec_1 // "totalFundsInvested"
    // smart_contracts/algo_smartcontract/contract.algo.ts:397
    // this.totalFundsInvested.value = this.totalFundsInvested.value + amount
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:11
    // totalActiveLoans = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalActiveLoans"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:398
    // this.totalActiveLoans.value = this.totalActiveLoans.value + 1
    intc_1 // 1
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:11
    // totalActiveLoans = GlobalState<uint64>()
    bytec 5 // "totalActiveLoans"
    // smart_contracts/algo_smartcontract/contract.algo.ts:398
    // this.totalActiveLoans.value = this.totalActiveLoans.value + 1
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:401
    // this.platformFees.value = this.platformFees.value + (amount / 50)
    frame_dig -1
    intc_3 // 50
    /
    +
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    bytec_3 // "platformFees"
    // smart_contracts/algo_smartcontract/contract.algo.ts:401
    // this.platformFees.value = this.platformFees.value + (amount / 50)
    swap
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:403
    // return 'Loan funding simulated successfully'
    pushbytes "Loan funding simulated successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getActiveLoansCount() -> uint64:
getActiveLoansCount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:11
    // totalActiveLoans = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalActiveLoans"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:419
    // return this.totalActiveLoans.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.togglePlatformStatus() -> bytes:
togglePlatformStatus:
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    intc_0 // 0
    bytec 4 // "contractActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:426
    // if (this.contractActive.value === 1) {
    intc_1 // 1
    ==
    bz togglePlatformStatus_else_body@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    bytec 4 // "contractActive"
    // smart_contracts/algo_smartcontract/contract.algo.ts:427
    // this.contractActive.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:428
    // return 'Platform deactivated'
    pushbytes "Platform deactivated"
    retsub

togglePlatformStatus_else_body@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    bytec 4 // "contractActive"
    // smart_contracts/algo_smartcontract/contract.algo.ts:430
    // this.contractActive.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:431
    // return 'Platform activated'
    pushbytes "Platform activated"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.collectPlatformFees() -> bytes:
collectPlatformFees:
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:441
    // if (fees <= 0) {
    intc_0 // 0
    <=
    bz collectPlatformFees_after_if_else@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:442
    // return 'No fees available for collection'
    pushbytes "No fees available for collection"
    retsub

collectPlatformFees_after_if_else@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    bytec_3 // "platformFees"
    // smart_contracts/algo_smartcontract/contract.algo.ts:446
    // this.platformFees.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_smartcontract/contract.algo.ts:451
    // return 'Platform fees collected successfully'
    pushbytes "Platform fees collected successfully"
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.getPlatformFeesAmount() -> uint64:
getPlatformFeesAmount:
    // smart_contracts/algo_smartcontract/contract.algo.ts:13
    // platformFees = GlobalState<uint64>()
    intc_0 // 0
    bytec_3 // "platformFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:458
    // return this.platformFees.value
    retsub


// smart_contracts/algo_smartcontract/contract.algo.ts::AlgoCreditPlatformTestNet.testPlatform() -> bytes:
testPlatform:
    // smart_contracts/algo_smartcontract/contract.algo.ts:14
    // contractActive = GlobalState<uint64>() // 1 = active, 0 = inactive
    intc_0 // 0
    bytec 4 // "contractActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/algo_smartcontract/contract.algo.ts:466
    // if (active === 1) {
    intc_1 // 1
    ==
    bz testPlatform_else_body@2
    // smart_contracts/algo_smartcontract/contract.algo.ts:467
    // return 'AlgoCredit Platform test successful - ACTIVE'
    pushbytes "AlgoCredit Platform test successful - ACTIVE"
    retsub

testPlatform_else_body@2:
    // smart_contracts/algo_smartcontract/contract.algo.ts:469
    // return 'AlgoCredit Platform test successful - INACTIVE'
    pushbytes "AlgoCredit Platform test successful - INACTIVE"
    retsub
